今天我们继续了解对象的生命周期

1.引用 

引用的生命周期等同于被引用的对象。这个很好理解，因为我们将引用理解为“被引用的对象本身”，那么作用域当然也等同于被引用的对象。

因此，我们绝对禁止将局部对象的引用（或指针）传递到作用域之外。像下面这样的例子是绝对禁止的：

int& f()        // 注意：函数的返回类型不对劲
{
    int x; 
    return x;       // 糟糕！返回了x的引用，但是x被销毁！
}

这时，我们像这样调用函数会引起大灾难：

int& num {f()};     // 糟糕：num已经被销毁！因为num是引用，其生命周期等同于被引用的对象

这种引用被称为“悬垂引用”，对应的指针版本被称为“野指针”。

f的正确版本如下：

int f()     // 返回普通的值就可以了
{
    int x; 
    return x;       // 正确
}

2.指向临时值的指针和引用

如果有两个string类型的变量s1和s2，使用它们的.c_str()方法可能带来一些意料之外的问题：
const char* s {(s1+s2).c_str()};
cout << s;      // 糟糕！ 

这是一段非常糟糕的代码。c_str()方法返回一个const char*类型的字符串指针，它指向了(s1+s2)这个临时值所管理的字符串。绝对禁止这样做！(s1+s2)这个临时值会当场去世，之后s就会指向一片无效的区域

【s1+s2】

【c_str for temp object】

我们仅仅在做参数时才能使用指向临时值的指针和引用：

string command {"color "};      // 注意别少了空格
string color {"e9"};
system((command+color).c_str());        // 正确

以上，system是位于<cstdlib>中的标准库函数，它本是C语言的函数，所以只接受const char*类型的字符串指针，不接受string类型的字符串。

(command+color)这个临时值在system函数调用完毕以后才销毁。所以这条语句不必担心提前销毁的问题。临时值的销毁时间是在“完整表达式”结束，“完整表达式”指不属于其他表达式的表达式

3.拷贝和移动

C++有四种语义经常令初学者混淆：拷贝构造、移动构造、拷贝赋值、移动赋值。其中“构造”的意思就是“初始化”。

要理解这四种语义，当务之急是要理解“拷贝”和“移动”的区别。

// 假如有个string类型局部变量s1
string s2 {s1};         // 拷贝构造，s2被分配一段独立的空间，并将s1的内容逐个拷贝到s2空间
string s3 {s1+s2};      // 移动构造，s3直接接管s1+s2这个临时对象所使用的空间
s3 = s2;                // 拷贝赋值，s2的字符被逐个拷贝到s3的空间
s2 = s1+s3;             // 移动赋值，s2先释放原空间，然后接管s1+s3这个临时对象的空间

由上述代码可知：对于管理着一些资源的类，比如字符串类（管理着一个字符串），“拷贝”会复制资源给目标对象，而“移动”是直接将资源交给目标对象。
这意味着，对新对象进行修改操作时，不会影响到“拷贝源”，但会影响到“移动源”。因为拷贝的新对象与原对象是相互独立的，而移动则不是

C++的移动语义是安全的，无需担心临时对象的销毁。销毁对象需要使用一个函数，被称为“析构函数”，析构函数是自动调用的。
移动语义是“破坏性读取”，一般的做法是，让s1+s2接管空指针nullptr，从而使s1+s2的析构函数无效化。请看图示：

【move】

拷贝语义不会破坏原对象，移动语义会破坏原对象。但是，移动操作的速度往往比拷贝操作快得多。

注意：“移动”和“传递引用”这两个操作看似非常相似，都是一个对象“接管”了另一个对象。但他们是有区别的：
传递引用是编译时简单地将一个对象看作另一个对象的别名，不涉及任何运行时的操作，也不破坏原对象。即使对象不管理资源，也可以传递引用。移动操作是运行时进行破坏性读取，将一个对象所管理的资源转移给另一个对象。

4.左值和右值

在第3条的示例代码中我们发现，在赋值和初始化时使用的值，有的会被拷贝，有的会被移动。

一般“有名有姓”的对象，比如上面的s1，是不会被移动的，因为移动语义会破坏对象。而临时值会被移动，以节省时间，提高性能。

不会被移动的值被称为“左值”，会被移动的值被称为“右值”。这个左和右常常被认为是对于赋值运算符=来说的，因为右值不能放在=的左边。最早确实如此，不过现在并不是这样，因为有的左值（比如const引用）也不能放在等号左边。

函数的返回值是一个右值，即使有名有姓也是：

string f()
{
    string str {"Hello world"};
    return str;     // str将来会被移动而不是拷贝
}

除此之外，标准库<utility>中还提供std::move()函数，用于强制移动某对象：
string s2 {std::move(s1)};      // s1本来是左值，但是被std::move强制移动、破坏。所以这句话是移动语义

std::move()有时可以提高性能，避免无意义的拷贝操作。但是要注意的是，被移动过的值是不能再继续使用的。我建议必须在确保一个变量真的不会再被使用的时候才能用std::move()移动它。
对于如int和double等不进行资源管理的内置类型，其拷贝语义与移动语义相同。我们一般不对这些类型使用std::move 

5.右值引用

普通的非常量引用其实又叫“左值引用”，右值是不能绑定到左值引用的。

double& pi {cos(-1)};           // 错误：cos(-1)是右值，不能传递到左值引用
double&& pi {cos(-1)};          // 正确：double&&是右值引用的意思。能延长右值的生命周期
const double& pi {cos(-1)};     // 正确：const引用是“左右通吃”的，也可以延长右值的生命周期

诸如 类型&& 的格式叫做右值引用。右值引用可以绑定一个右值，并延长该右值的生命周期。但是右值引用本身不能移动（是个左值）

string&& rref {s1+s2};     // rref绑定到s1+s2这个右值
string foo {rref};         // 这是 拷贝 构造！rref本身不能移动（是个左值）
foo = rref;                // 这是 拷贝 赋值！原因同上
foo = std::move(rref);     // 正确：强制移动，同时破坏rref。

右值引用只能绑定右值，不能绑定左值。所以它的作用是判断一个对象是否为右值。

作业：

1.请选择下列正确的一项：
A.为了提高效率，函数可以返回局部变量的指针或引用
B.右值引用会接受右值的移动，但本身不能移动（除非使用std::move）
C.对于int类型而言，拷贝和移动是不相同的
D.对于管理资源的类型而言，移动的速度往往比拷贝要更快一些

2.下列哪一个操作是“移动”语义：
A.小明抄小红的作业
B.小明将橡皮借给小红使用
C.小明买了一支铅笔
D.小明将书借给小红阅读
