今天我们了解一下常见运算符。

在查阅编程资料的时候，我们常常碰到“X目运算符”这样的概念。

所谓“X目运算符”是指该运算符有X个操作数。比如-作为减号时是双目运算符，因为减号需要被减数和减数这两个操作数。而作为负号时它是单目运算符，因为负号只需要一个操作数的跟随。

1.双目运算符 + - * / %

这五个运算符在作为双目运算符时，如果它的两个操作数的类型不相同，则会先进行类型转换以转换为相同的类型。这个转换操作对于程序员是透明的。
所谓“透明”是指“不可见，可无视”的意思。这种“透明”的类型转换被称为“隐式类型转换”。

* / % 的运算优先级高于 + - 。如果在同一条表达式中出现优先级不相等的运算符，则会先进行优先级较高的运算。
比如 a+b*c ，它等价于 a+(b*c) ，因为*的优先级高于+

对于两个整数而言，/运算符是整除，它的返回值是整数。比如5/2，其含义为2整除5（5整除以2），结果为2而不是2.5
对于两个小数而言，/运算符是精确的除法，返回值也是小数。比如 5.0/2 或 5/2.0 或 5.0/2.0 ，这三个表达式都表示5.0除以2.0，其结果为2.5。

0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！0不能作除数！
程序员在看到除号时必须警惕，程序员有义务保证除号的右边不是0。程序在遇到除以0的表达式时，会立刻崩溃。

%的两个操作数都应当是整数，它表示求余数。比如 10%4 ，其结果为2，表示10除以4的余数为2。

如果a%b的结果为0，就说a可以被b整除。比如6%3等于0，就说6可以被3整除。

这五个运算符都是算术运算符。算术运算符不会改写它的操作数。诸如 a+b 这样的表达式，只会算一个结果出来，并不会更改a和b的值。

2.单目运算符 + - *

+作为单目运算符时一般没啥用……

-作为单目运算符时表示负号。负号的运算符优先级比较高，以至于即使碰到 * / % 这些运算符，也依然会先算负号。
所有运算符的优先级表，可以查阅教材第221、222页

*作为单目运算符时表示解引用。虽然名叫“解引用”但其实解的是指针和迭代器

+ - * 作为单目运算符时也依然不会改动其操作数。

3. > < >= <= == !=

这几个运算符都是关系运算符，双目，其运算结果都是bool类型。bool类型是逻辑类型，这个类型只有两个值：true和false。true表示真，false表示假。

比如 3>2 ，其结果为true。而 3==2 的结果为false。

除了0.0以外，==不能用于浮点数判等。它可能会出现错误的结果
比如  0.1+0.2 == 0.3  的结果是false。

关系运算符不会改写其操作数

4.赋值

赋值运算符是一个等于号'='。我们对它已经非常熟悉了。等号左侧往往是一个变量，而右侧可以是其他变量，也可以是常量或表达式。

等号左边不能是常量，尤其是字面量。也就是说，诸如 1 、 3.14 、 "Hello world" 、 true 这些东西不能放在等号的左边——但是可以放在右边。

等号左边也不能是表达式和函数返回值。诸如 a+b 、 acos(-1)  这些东西也不能放在等号的左边——但是可以放在右边。
所以  1+1 = 2  是错误的。

能改动自己的操作数的运算符很少，赋值运算符算一个。

赋值运算符的优先级极其低下，几乎所有其他运算符都高于赋值运算符。

5.++ --

自增自减运算符会改写自己的操作数。

++a的意思是先自增a，然后作为结果返回。a++的意思是先保存a作为结果，然后自增a。

int num {5};
int a {num++};      // a的值为5，num的值变为6
int b {++num};      // num的值变为7，b的值也为7

为了避免++被解释为两个+号，C++采用“最长匹配规则”解释运算符。也就是说，在解析运算符的时候会选择尽可能长的序列。这意味着++永远不可能被解释为两个+号：
a++b;       // 语法错误！不是a + +b，而是a++ b。
a+++b;      // 正确。a++ + b
再说一遍，不要在这种地方使用后置++

无论前置还是后置，自增自减运算符会改写自己的操作数。我们不应当在同一条表达式中读写同一个值。
这意味着自增自减运算符的操作数不能在同一条表达式中再次出现。

别的在以前的课程中已经讲过了，不再多说

6.逻辑与或非

有时我们需要同时检测多个bool类型的条件，这时候就需要请出我们的逻辑与或非。

if (a>b and a%b==0)
    cout << "b是a的因数";

我们看其中的  a>b and a%b==0  它的意思是，b不仅小于a，而且还能整除a。

显然，and的含义是“并且”。它是一个双目运算符，两个操作数都是bool类型。如果不是bool类型，会发生隐式类型转换。
只有两个操作数都是true，and才会返回true。否则，只有有一个为false，and就会返回false。

与and对应，or的含义是“或”。or也是一个双目运算符，接受两个bool类型的操作数。只要有一个操作数为true，or就返回true，只有两个操作都为false，or才返回false。

为了节省性能，当and发现a>b为假时，就不会再去测试a%b==0，而是直接返回false。同理，or在发现左侧为true时，也不会再管右侧的操作数
这种规则被称为“短路法则”。

not是最具有叛逆心理的逻辑运算符，它的含义是取反。not只有一个操作数，因为它无法容忍有操作数放在它前面，所以没有后置not。
当操作数为true时，not会返回false；当操作数为false时，它会返回true。

逻辑运算符都不会改动其操作数

and or not 都是C++关键字。在C语言中，它们本是三个运算符 && || !

我们认为 and or 的可读性高于 && || ，除此之外没有任何区别
而not和!的可读性不分伯仲，两个看起来都很叛逆

在C语言中也可以使用 and or not 代替 && || !，只需要 #include <iso646.h> （C++不需要）

and和or的运算符优先级很低，这意味着它们的两侧最好要加空格。
其他运算符同理：在一个表达式中，优先级最低的双目运算符两侧应当加空格。

值得注意的是，and和or的运算符优先级并不相同。这意味着and与or同时出现时，应当使用括号指明运算顺序。

7.条件表达式

我们常常碰到这样的情况：

if (bool类型的条件)
    cout << a;
else 
    cout << b;

条件表达式 ? : 运算符可以简化这种代码的编写。

形如  条件 ? a : b  的表达式，其意思是，如果条件为true结果就是a，如果条件为false结果就是b

所以上面代码可以改写为：
cout << ((bool类型的条件) ? a : b);       // 注意条件表达式的运算符优先级低于<<

条件表达式的运算符优先级极低，但是高于赋值。条件表达式不会改动其操作数

【Quote condition】

8.位与或非

我们知道，目前的计算机都采用二进制。任何一个数值都有二进制的形式。

我们用0b前缀表示一个二进值数值。比如0b101，就是60
用0x前缀表示一个十六进制数值。比如0xFA，就是250
用0前缀表示一个八进制数值。比如0721，就是465

一定要注意0前缀表示的是八进制数值而不是十进制，所以0721是465而不是721
八进制在编程中极少遇到

进制是数值的显示方式，而不是数值本身的属性。

假如有foo=60，bar=13。则
foo 为 0b00111100
bar 为 0b00001101

&作为双目运算符时，是按位与运算符。运算结果的第x位取决于两个操作数的第x位，如果两个操作数的第x位都是1，结果的第x位才是1，否则就是0
foo&bar 为 0b00001100

任何数&0都是0

|是按位或运算符
foo|bar 为 0b00111101

任何数|0都等于它本身

^是按位异或运算符，双目。运算结果的第x位取决于两个操作数的第x位。如果两个操作数的第x位不相同，则结果的第x位是1，否则就是0
foo^bar 为 0b00110001

注意foo^bar绝对不表示“foo的bar次方”，而是表示“foo和bar的异或”

任何数^它自己都等于0

~是位取反运算符，是最具有叛逆心理的位运算符。和not同理，它无法容忍操作数放在它前面。
~foo 为 0b11000011

位运算符都不会改写其操作数

9.位左右移

在学习cin和cout时，我们已经见过了<<和>>运算符。对于流而言，<<和>>表示数据的流动方向。但是对于整数而言，他们是位左移和位右移

比如foo<<1，它表示foo的所有位左移一位，最左侧位舍弃，右侧补0。所以它的结果为0b01111000
比如foo>>2，它表示foo的所有位右移两位，最右侧两位舍弃，左侧正数补0负数补1。所以它的结果为0b00001111

<<和>>在作为位运算符时不会改写其操作数，只有作为流io运算符时会改动其操作数。因为在作为流io运算符时，他们发生了重载。我们以后会学到

10.算术赋值

有时我们会碰到形似 X= 的运算符，这种运算符是算术赋值

比如  a += b  等价于  a = a+b 
比如  a -= b  等价于  a = a-b 

*=  /=  %=  <<=  >>=  &=  |=  ^= 也都同理。

算术赋值运算符的优先级等同赋值运算符，也是极低。

作业：

1.查阅教材第221、222页，and和or的运算符优先级谁更高？

2.解释以下代码的含义： 
a ^= a >> 13;

3.解释以下代码的含义：
// a b c都是bool类型的值
if (a or b and c)
    cout << "这句代码在什么时候运行？";

4.由于and和or的运算符优先级问题并不广为人知，所以第三题代码可读性较差。请在合适的位置加括号，让第三题代码没有歧义。

5.闰年的规律为：四年一闰，百年不闰，四百年再闰。
意思是：如果年份能被400整除，就一定是闰年。否则，如果能被100整除就一定不是闰年，否则如果能被四整除就一定是闰年
请用且只用一个if，判断某年份是否是闰年。如果是闰年就输出“闰年！”，如果不是闰年就什么都不做。
