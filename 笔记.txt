在小熊猫C++和Qt里各创建一个“实验室”项目，用以随意折腾。

学习我的教程，就必须完成我所有的作业。如果你不完成我的作业，那么你连本教程十分之一的内容都学不到。

不要忽略我代码中的空格和空行，他们都有其意义的

plainTextEdit组件使用setPlainText(text)修改其文字，不是setText
如果没有富文本的需求，就应该使用普通文本的plainTextEdit。因为富文本的性能比普通文本的性能差，也就是说，当你要显示很大量的文字时，使用富文本会拖慢程序的速度
同理，如果没有多行文本的需求，就应该使用单行文本框

关闭所有HTML元素，包括空元素

嵌套使用标签时，标签的关闭顺序与开始顺序相反

编辑Text Browser等组件的html时，请在“源文”栏中编辑，不能在“格式文本”栏中编辑。可能会有没用的初始代码，请先清除

一般情况下，使用花括号初始化的方式初始化变量

拒绝使用NULL这样的整数作为空指针，请使用nullptr代替它

小熊猫中，使用空格就可以关闭那讨厌的自动补全提示框。

C++将所有C语言的头文件都改了名，前面加c，后面删除.h。我称这样的库为“C源库”
C源库将原先的函数纳入std命名空间之内，但同时也在全局名字空间中保留着原先的函数

main函数的返回值一定是int，拒绝void main

优先使用C++的cout和cin代替printf和scanf，前者比后者又快又安全

很多时候追求运行速度，不惜以编译速度为代价

使用cout.sync_with_stdio(false);为cout加血

拒绝使用endl，用普通的'\n'代替它

在函数重载中，NULL会被匹配到整数参数，nullptr才会匹配到指针参数。

拒绝使用using namespace std;用using std::xxx;的格式代替它

fixed和setprecision常常配合使用

in表示数据在流的里面，要向外出
out表示数据在流的外面，要往里进
千万别弄反了！

不能用cin >> str的方式读入带空格的字符串，用std::getline(cin, str)替换它
cin也可以替换为其他输入流，str前不允许加取地址符&

即使在Qt中，'A'也是char而不是QChar，"string"也是const char*而不是QString

用cin.get(char)的方式避免cin跳过空白符

使用字符分类函数而不是猜测字符的数字值和数字值的特征

不默认int、double等类型的大小和取值范围是固定的，如果必须要固定，请使用int32_t类似的类型

优先使用int作为整数，使用double作为小数，不滥用float、unsigned等，避免冗余的类型转换。

只能对整数类型使用switch语句，不能对其他类型（小数、字符串等）使用switch

使用cout输出普通信息，使用cerr输出错误信息

在初始化istringstream时应当给予初始字符串，初始化ostringstream不应当给予初始字符串

避免长字符串连加，使用ostringstream构造长字符串

优先选择string（或QString）代替char*作为字符串，选择vector（或QList）代替传统数组

对于容器而言，圆括号初始化使用一个整数和一个可选的初始值作为参数，其语义为加入若干个初始值的数量。而花括号初始化的语义为提供初始值本身。
由于语义不相同，所以两者无法互相替代。

严禁越界访问数组，不然可能会使程序直接崩溃

auto常用于以下两种情况：
1.变量类型经常变动，或者随其他代码的变动而变动。比如数组元素类型
2.某些函数返回值是冷门或长类型，或者易错的类型。使用auto接受这样的函数的返回值

auto标配等于号初始化，避免对auto使用花括号初始化

使用范围for作为遍历容器的默认方式

如果一个变量使用了自增或自减运算符，那么这个变量在这条语句中绝对不允许出现第二次

与后置++相比，优先使用前置++运算符

array.end()方法返回的是最后一个元素再后方一个元素的迭代器，这个迭代器是无法使用的
array.rend()方法返回的是最前一个元素之前的元素的迭代器，这个迭代器也是无法使用的

对一个倒序迭代器使用++，它会指向前一个元素而不是后一个元素。--会指向后一个元素

for循环的规范写法：
for (int i{}; i!=n; ++i)
for (auto i=a.begin(); i!=a.end(); ++i)
for (auto i=a.rbegin(); i!=a.rend(); ++i)       // 即使是倒序迭代器，依然使用++而不是--

insert会将一个元素插入到pos之前而不是之后

push_back()和insert()方法可能使原先所有元素的引用和迭代器全部失效

正是由于它们常常失效的缘故，我们才不应当将元素引用或迭代器保存到（除循环变量以外的其他）变量中。毕竟谁知道它们什么时候失效呢？

倒序迭代器只能用于倒序遍历容器，不能用于insert、erase等其他用途

标准算法库<algorithm>中的函数常常接受两个迭代器[first, last)作为范围
last指向最后一个元素的后一个元素，不是最后一个元素！

算法库中所有的函数都是全局函数，不是vector的方法。

不仅要形成自己的代码风格，也要尊重他人（同样优秀）的代码风格
不仅要尊重他人（优秀）的代码风格，也要形成自己的代码风格

不必苛责自己过去写过的代码，只需要将优秀的代码风格用在自己现在和未来的代码中即可

程序员应当使用英语作为变量名。如果使用其他语言，你的代码将无法与国际接轨。这对于很多国际化的大项目是非常不利的。

请使用字母开头的名字。下划线开头的名字可能被编译器预定义用作特殊用途，而数字开头的名字不能作为标识符。

为变量谨慎起名，一个好的变量名对于程序的可读性来说非常重要。拒绝使用没有含义的变量名
单字母变量不一定没有含义，多字母变量也不一定有含义。请认真起名

变量名应当反映变量的含义或用途，而不应当暴露其实现细节。
比如说，不应当将变量的类型或作用域等信息包含在变量名中。拒绝使用匈牙利命名法

引用和传统指针的变量的声明应当放到单独一行：
int* p, q;      // q是int类型而不是int*。请避免这种容易引起混淆的写法：将p的声明放在单独一行

对于两个整数而言，/运算符是整除，它的返回值是整数。比如5/2，其含义为2整除5（5整除以2），结果为2而不是2.5
对于两个小数而言，/运算符是精确的除法，返回值也是小数。比如 5.0/2 或 5/2.0 或 5.0/2.0 ，这三个表达式都表示5.0除以2.0，其结果为2.5。

0不能作除数。程序员在看到除号时必须警惕，程序员有义务保证除号的右边不是0。

诸如 a+b 这样的表达式，只会算一个结果出来，并不会更改a和b的值。
<<和>>运算符，他们在作为左移和右移的时候不改变操作数，但是作为流io运算符时会改动对应的流。

==不能用于浮点数判等。==判浮点是未定义行为。比如  0.1+0.2 == 0.3  的结果是false。

and or 的可读性强于 && || ，除此之外没有任何区别

and和or有“短路法则”

and和or的运算符优先级很低，这意味着它们的两侧最好要加空格。
其他运算符同理：在一个表达式中，优先级最低的双目运算符两侧应当加空格。

and和or的运算符优先级并不相同。这意味着and与or同时出现时，应当使用括号指明运算顺序。

条件表达式的条件部分建议加括号，以便阅读

一定要注意0前缀表示的是八进制而不是十进制，所以0721是465而不是721
八进制在编程中极少遇到

注意A^B绝对不表示“A的B次方”，而是表示“A和B的异或”

除and和or外，其他双目运算符的运算结果绝对不能依赖于操作数的求值顺序。这要求程序员保证，对一个操作数求值时绝对不能影响到另一个操作数。

在代码块内可以声明和定义块内局部变量，块内局部变量不能在块外使用。

不要混淆逻辑等于运算符==和赋值运算符=

将测试目标（变量）放在==的左边，把测试工具放在==的右边

条件运算符不允许连续，把  a < num < b  改成   num>a and num<b 

如果两层if跟一个else，则外层if一定要带大括号，无论else属于哪个if。

想要检查一个整型或枚举值是一组常量中的哪一个，使用switch语句

switch不能检查小数和字符串

switch语句的每一个分支都应当有一个break或return。如果确实需要继续执行下一个分支，做好注释。

在case分支中声明变量时，应当使用花括号将该变量的作用域限定在该case分支中

do-while语句的while后面是有分号的

使用无限循环有两种场景，一种是循环条件在循环体中间，另一种是循环条件比较复杂（需要多行）

const是个好东西，程序员应该多用

函数传参若要传递大对象，使用const&。如果传递需要修改的对象，使用普通&

避免过于复杂的函数，包括main函数。将复杂功能分解为多个小功能，以保持每个函数的规模较小
保持每个函数简短可以增加代码的可读性和可维护性

默认值需要在声明中说明，但不能出现在定义中

头文件中不得出现（非inline）函数定义、变量定义，只能出现声明和类定义

使用类型和初始化器进行非窄化类型转换，使用static_cast进行窄化类型转换

小数到整数的窄化转换会截断小数部分，而不是四舍五入。用<cmath>中的round()函数进行四舍五入

从int到double的转换也是窄化转换

不要使用C风格类型转换，比如 (int)3.14

不管是哪一种类型转换，都是创建一个新的值，而不是像字面意思上把对象本身给转换类型。被创建出的新值是临时值。

尽量减少全局变量的使用，用静态变量或名字空间变量替代它。如果非要定义全局变量，做注释

名字空间变量的生命周期与全局变量等同，定义名字空间变量时也最好注释

通常情况下，将函数声明放在头文件，把函数定义放在cpp文件

成员变量被整个类所享用，其他变量的作用域起于声明处

禁止将局部对象的引用或指针传递到作用域之外

仅仅在做参数时才能使用指向临时值的指针和引用

临时值的销毁时间是在“完整表达式”结束，“完整表达式”指不属于其他表达式的表达式

对于管理着一些资源的类，比如字符串类（管理着一个字符串），“拷贝”会复制资源给目标对象，而“移动”是直接将资源交给目标对象
对于如int和double等不进行资源管理的内置类型，其拷贝语义与移动语义相同。

拷贝语义不会破坏原对象，移动语义会破坏原对象。但是，移动操作的速度往往比拷贝操作快得多。

传递引用是编译时简单地将一个对象看作另一个对象的别名，不涉及任何运行时的操作，也不破坏原对象。即使对象不管理资源，也可以传递引用。移动操作是运行时进行破坏性读取，将一个对象所管理的资源转移给另一个对象。

必须在确保一个变量真的不会（在被重新赋值之前）再被使用的时候才能用std::move()移动它。

右值引用本身不能移动（是个左值），只能被std::move()强制移动

右值引用的作用是判断一个对象是否为右值

当几个函数在功能上一致，仅仅是处理的类型有区别时，我们就可以考虑使用重载。

如果在函数重载时
1.参数在类型转换前无匹配
2.参数在类型转换后有多个匹配
则可能会引发二义性错误
因此，我们设计重载函数时，最好优先考虑精确匹配。精确匹配的优先级高于类型转换的匹配，有精确匹配时不会引发二义性错误

auto返回值只是类型推导，它不允许函数返回多种类型

C源库<cxx>会在std命名空间中纳入所有<xx.h>的函数，但同时也在全局命名空间中保留了这些函数























将来的教学任务：
被inherits的函数为什么可以用：继承
定义<用于排序：运算符重载
删除最后一个元素最快、不重复随机数：随机数引擎
函数和全局变量的（多文件）声明：多文件编译
const与constexpr前缀
注释风格
类型转换（隐式类型转换讲指针和整数到bool类型）：指针
宏和全大写名字：宏
深入多文件编程（函数不重复、#ifndef等等）。要理解编译器只能分析单文件和链接器可以找到见天涯海角的区别
结构体和类的用途区别：类
小熊猫C++和QtCreator的调试功能：快排之前
不要重载 and or not ：运算符重载
函数参数的求值顺序不固定
文件编码是ANSI，小熊猫可以转
不允许使用的goto
省略循环体用分号
缩进
递归
严禁exit(0)：析构函数
对于类的单一定义规则：多文件编译
其他类型转换（reinterpret_cast、dynamic_cast、const_cast）
隐藏名字：宏
局部对象指针不轻传：智能指针
std::optional
规范要求：被移动后的对象（移出状态）依然可以被赋值：移动构造函数
vector.push_back(aaa)不是移动，而是拷贝
子类到父类的“切片拷贝”
基类和派生类被屏蔽的函数重载
拷贝构造、移动构造、拷贝赋值、移动赋值在最后再讲解
（以上，不要把我的 string{"false"} 简化为 "false" ，否则你会发现程序不会报错。原因以后再讲）：指针
原始字符串字面值常量：文件路径
构造函数中不能使用被子类所覆盖的virtual函数：继承
构造函数抛出异常时，析构函数不执行，但是成员会析构：析构函数
Penny McDonald 7岁的作业：随机数
