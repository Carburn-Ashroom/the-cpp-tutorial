今天我们来学习一下C++的基本类型

C++拥有两种类型，即内置类型和用户自定义类型。在其他一些语言中可能将用户自定义类型叫做引用类型，注意在C++中并不这样称呼。

内置类型又分为基本类型和基本类型的指针、数组、引用

基本类型就是像int, double, bool等等被编程语言自带的类型。注意bool类型在C23之前的C语言中是没有的，而C++一直都有

1.char

char是一个字符，这个字符只有一个字节，所以不能存储汉字或者其他超过1个字节的字符。
这一点与Qt中的QChar不同，QChar可以存储任意大小的一个字符，也就是说QChar是可以存储汉字的

由单引号引起来的一个字符是一个char类型的常量，比如'A'
注意：即使是在Qt中，'A'也是char类型而不是QChar。因为QChar毕竟是Qt自定义的类型。Qt只是在C++的基础上多加了一些类型，它不会更改C++的基础。
由双引号引起来的一句话是一个const char*类型的常量，不是std::string类型，更不是QString类型

输入流在向char类型变量输入时，依然会跳过空白符：
char ch; 
cin >> ch;      // ch是cin中第一个非空白符

如果不想跳过空白符，应当使用cin.get(char)方法：
char ch; 
cin.get(ch);        // 注意ch被放在参数的位置，而且绝对不允许加取地址符&。

另外，C++中的字符并不一定是ASCII（读作askey）编码，这也就说明我们不应该去猜测一个字符的数字含义，也不应当对该数字的性质进行揣测：
char alpha {'B'};        // alpha的数字含义一定是66吗？一定在'A'和'Z'之间吗？
关于这一点，C++之父早已给出答案：

【char traits】

如上图所示，丹麦比英国多出来三个字母，分别是Ø, Æ, Å。因此我们不认为'B'一定是66，因为其不使用ASCII
因为除了ASCII以外一定存在其他编码，而不同的编码中'B'不一定是相同的
顺带一提，C++之父本来就是丹麦人

“字符分类函数”定义于<cctype>中，可以判断一个char的性质，比如是否是小写字母。
而QChar拥有自己的字符分类函数，其名字和<cctype>中的函数大多是一样的，但也有少量区别，且调用方式稍有差异：

【isupper】

【qt isupper】

2.short int float double 

C和C++中默认的整数是int，默认的小数是double。这包括但不限于表现于以下方面：

(1) 字面值常量（也就是常说的“立即数”）整数默认是int，小数默认是double。需要另加后缀才能表示short和float
比如1是int类型，3.14是double类型（不是float）
(2) 标准库函数的参数和返回值往往以int为整数，以double为小数。
比如  double sin(double)  函数，其参数和返回值都是double类型。

int表示在本机器中最“自然”的大小的整数。这意味着int并不一定是4个字节大小。在16位的系统中，以及很多嵌入式设备里，int占2个字节。而在少数特殊的linux系统中，int已经占到8个字节。
double作为最适配的小数类型，也同理。
C和C++都诞生于16位操作系统盛行的时代，所以C语言和C++标准中规定的int类型的大小都是最少两个字节，可以更多。

【least size】

如果要取到int的大小，使用sizeof(int)即可。不建议默认int为4个字节大小
如果一定要使用确定大小的整数，请使用int32_t等类型，它们定义于<cstdint>：
int32_t value {};       // 一定是4字节大小的有符号整数。32 = 4（字节） x 8（位）
uint64_t big_val {};    // 一定是8字节大小的无符号整数。64 = 8（字节） x 8（位）

在C++中，类型转换往往在运行时才能完成。也就是说，如果使用float代替double的话，可能时不时要付出类型转换的代价。

很多人认为既然float比double小，那么用float是追求性能的表现。其实这种看法是愚蠢的表现。
请看以下示例：
float angle = 3.1415927/4;      // 注：按四舍五入的规则，π的第8位是5，故进位为3.1415927
float radius = 8.88;            // 半径
float x = radius * cos(angle) * 1.2;    // 这行代码拥有多少次类型转换？

全局的cos函数，其参数和返回值都是double类型。 因此angle会被转化为double类型作为cos的参数。
加减乘除等运算符（双目运算符）要求两侧类型相同，若不相同，则小类型会被提升为大类型。乘号左侧为float类型，右侧为cos函数返回值的double类型，故乘号左侧的radius被提升为double类型
double的乘法表达式返回一个double类型的结果，需要将这个结果赋于float类型变量，又发生一次类型转换。

C++提供  float std::cos(float)  这个重载，它在std命名空间里，不在全局。
尽管如此，并非所有的函数都拥有重载，尤其是，返回值不能重载，运算符也没有默认重载。
在使用std::cos时，虽然radius*cos(angle)不发生类型转换，能得到float类型的中间结果。但是在后面*1.2时，由于1.2是double类型，所以float类型的中间结果依然要提升为double，而总结果是double类型。要赋于float类型的变量x，还要发生类型转换。

我故意使用了等于号初始化的方式，因为这三次赋值全部都是窄化转换。
如果使用double代替以上三个float，便可以使用{}初始化器，而且三行代码不存在一次类型转换。

在全局命名空间里还有  float cosf(float)  函数，不过我觉得没啥大用。它的函数名已经不是cos，无法用于重载（自动适配类型）。

3.unsigned

我们知道C++的基本类型有大小之分。判断两个类型大小的标准是，小类型的取值范围被包含在大类型的取值范围中

所以两个类型即使取值范围不一也依然不存在大小关系。
比如int和unsigned int。unsigned是无符号的意思，也就是没有负数。所以int比unsigned多了负数。而unsigned将负数的编码都拿去做了更大的正数，所以unsigned的最大正数约是int的两倍大小

由于加减乘除这类的运算符，其两侧要求类型相同。所以如果int和unsigned分别出现在这类运算符的两侧时，两个操作数往往会被同时提升为long long类型
这可能会造成更多的类型转换。所以，我们也不提倡乱用unsigned。

作业：
判断用户输入的字符是字母、数字、空白符还是其他符号

【task】
